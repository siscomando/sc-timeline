<link rel="import" href="../font-roboto/roboto.html">
<link rel="import" href="../core-list/core-list.html">
<link rel="import" href="../core-icon/core-icon.html">
<link rel="import" href="../core-icons/communication-icons.html">
<link rel="import" href="../core-ajax/core-ajax.html">
<link rel="import" href="../star-rating/star-rating.html">
<link rel="import" href="../sc-link/sc-link.html">
<link rel="import" href="../paper-elements/paper-elements.html">

<!--
Element providing the timeline to any apps.

##### Example

    <sc-timeline></sc-timeline>

@element sc-timeline
@blurb EElement providing the timeline to any apps.
@status alpha
@homepage http://github.com/siscomando/sc-timline
-->
<polymer-element name="sc-timeline" attributes="notitle author data emptyavatar url sseurl ssechannel ssealias scope gravatarEnabled">

  <template>
  <core-ajax
  auto
  url="{{url}}"
  handleAs="json"
  response="{{response}}"
  ></core-ajax>

  <sc-sse stream="{{sseurl}}" channel="{{ssechannel}}" alias="{{ssealias}}">
  </sc-sse>
  
    <link rel="stylesheet" href="sc-timeline.css">
    <div class="mainContent" flex horizontal layout>
      <br>
      <core-list id="coreList" data="{{response.comments}}" runwayFactor="12" height="48" flex>
        <template>
          <!-- begin post 
          TODO: new core-list template to support list users
          -->
          <div id="id{{ model._id.$oid }}" class="row timeline-post {{ {selected: selected} | tokenList }} item-{{ model._id.$oid }}" horizontal layout>
            <div class="columns shottime">{{ model.shottime }}</div>
            <div class="columns division-icon">
              <core-icon icon="{{ setIcon(model.origin) }}" class="pallete-icon-color autumn"></core-icon>
            </div>
            <div class="columns content" flex>
                <div horizontal layout>
                  <div class="thumbnail">
                    <!-- if gravatarEnabled -->
                    <template bind if="{{ gravatarEnabled == 'true' }}">
                      <img src="{{ getGravatarUrl(model.author.User.md5_email) }}">
                    </template>
                    <template bind if="{{ gravatarEnabled != 'true' }}">
                      <img src="{{ model.author.User.avatar || emptyavatar }}">
                    </template>
                  </div> 
                  <div class="author-info" flex>
                    <div class="username">{{ model.author.User.shortname }} 
                      <span class="title">at {{ model.title }} <template if="{{model.issue_id.Issue.register}}">|</template> <sc-link>{{model.issue_id.Issue.register}}</sc-link></span>
                    </div>
                    <div class="location">{{ model.author.User.location }}</div>
                    <div class="timepost">{{ model.created_at_human }}</div>
                  </div>
                </div>
                <div class="stars">
                    <star-rating votes="{{ model.stars }}" votesSum="0"></star-rating>
                </div>
                <div class="post" on-tap="{{getFullContent}}">
                    {{ model.body | ellipsis }}
                </div>
            </div>
          </div>
          <!-- end post -->
        </template>
      </core-list>
      
    </div>

      <core-ajax
        id="coreAjaxIssues"
        url=""
        handleAs="json"
        on-core-response="{{getIssue}}">
      </core-ajax>
         
  </template>

  <script>

    Polymer({
      /**
       * The `author` attribute sets an initial author
       *
       * @attribute author
       * @type string
       * @default 'Horacio Ibrahim'
       */
      /**
       * The `url` attribute sets an url to get the timeline's data.
       *
       * @attribute url
       * @type string
       * @default ''
       */ 
      /**
       * The `scope` attribute sets an scope for timeline (e.g: #wall, ticket)
       *
       * @attribute scope
       * @type string
       * @default null
       */               
      author: 'Horacio Ibrahim',
      publish: {
        // publics properties
        emptyavatar: "static/assets/img/avatar-empty.png",
        url: '',
        sseurl: '',
        ssealias: 'sseTimeline',
        sseurlOriginal: null,
        urlOriginal: null,
        response: '{"comments": "[]"}',
        scope: null,
      },
      /* the best place to the constructor for array or object */
      created: function() {
        // initialize but it not is turned public to use by users of the element
        // to turn public to use attributes or publish.    
        // init response       
      },
      ready: function() {
        // keep original url's
        if (this.sseurlOriginal === null) {
          this.sseurlOriginal = this.sseurl;    
        }
        if (this.urlOriginal === null) {
          this.urlOriginal = this.url;    
        }
        // var scnavbar = document.querySelector('sc-navbar');
        var timeline = this;
        this.changeURL(document, 'sc-select', timeline);
        var currentElem = this;
        this.updateComment(document, currentElem);

        // if sc-response fired to changed the timeline response
        document.addEventListener('sc-response', function(ev) {
          currentElem.response = ev.detail.response;
        });

        this.$.coreList.focus();
      },
      /**
       * The `changeURL` change URL of the core-ajax to get data from specif
       * item.
       * 
       * @method changeURL
       * @param source the instance that will to generate an event
       * @param eventName the name of the event generated by source 
       * @param callback a callback function or this custom element
       */       
      changeURL: function(source, eventName, callback) {
        source.addEventListener(eventName, function(e){
              var ajaxLocal = callback.$.coreAjaxIssues;
              register = e.detail.issue;
              register = register.replace('/', '');
              callback.scope = register;
              new_url = callback.urlOriginal + register + '/'; 
              callback.url = new_url;
              ajaxLocal.url = '/api/v1/issues/' + register;
              ajaxLocal.go();
        });
      },
      getIssue: function() {
          var ajaxLocal = this.$.coreAjaxIssues;
          this.sseurl = this.sseurlOriginal + ajaxLocal.response.issue._id.$oid;
      },     
      /** `The updateTimeline` updates the timeline based in returned data from
      * sse event (emit): sc-sse-response
      *
      * @param ontop if true the payload is added in top of the timeline. Rather
      * the update is added in bottom.
      * @param 
      */
      updateComment: function(source, currentElem) {
        source.addEventListener('sc-sse-response', function(e){
          if (currentElem.response == null) {
              currentElem.response = {"comments": []};
          }  

          // Tests if the response has content valid or is only retry
          // if newComment is true has response!         
          if (('alias' in e.detail) && (e.detail.alias == 'sseTimeline') && (e.detail.response != 1)
              && (e.detail.response != null) && (e.detail.response != undefined)) {
              switch(typeof(e.detail.response)) {
                case 'string':
                  var newComment = JSON.parse(e.detail.response);
                  break;
                case 'object':
                  var newComment = e.detail.response;
                  break;
                default:
                  var newComment = false;
              }

          // wrapper that fix dual newComment
          if ('comments' in  newComment) {
              newComment = newComment.comments;
          }
          // This point begins the real update
          if (!(newComment == false)) {
              var containsComment = false; // content of the comment 
              var order = null;
              for (var i=0; i < currentElem.response.comments.length; i++) {
                item = currentElem.response.comments[i];
                itemId = item._id.$oid;
                commentId = newComment._id ? newComment._id.$oid : null;
                if (itemId == commentId ) {
                    containsComment = true;
                    order = i;
                }
              }
              // check scope
              if ((currentElem.scope === null) || (currentElem.scope == newComment.issue_id.Issue.register)) {
                  if (containsComment == false) {
                     currentElem.response.comments.unshift(newComment);
                  } else {
                     currentElem.response.comments[order] = newComment;
                  }
                   var lastPost = currentElem.shadowRoot.querySelector('.timeline-post');
                   lastPost.style.opacity = "0.0";
                   currentElem.fadeObject(lastPost, 0, 1, 1250);                  
              }         
              // end real update            
            }                   
          }
        });
      },
      setIcon: function(origin) {
        if (origin == 0) {
          return 'communication:chat';
        }
        if (origin == 1) {
          return 'communication:business';
        }        
        if (origin == 2) {
          return 'communication:email';
        }
        // default
        return 'communication:no-sim';
      },
      getFullContent: function(event, detail, sender) {
        var comment = sender.templateInstance.model.model;
        this[comment._id.$oid] = comment;
        sender.innerHTML = this[comment._id.$oid]['body'];
        sender.style.height =  "100%";
      },      
      ellipsis: function(body) {
        if (body) {
          if (body.length > 200) {
              // save content
              bodyHidden = body.slice(200);
              // resize body
              body = body.slice(0, 200);
              body = body + "...";
              return body;
          } else {
            return body;
          }
        }
      },        
      /**
      from: http://stackoverflow.com/a/9145985/2283488
      */
      fadeObject: function (el, start, end, duration) {
          var range = end - start;
          var goingUp = end > start;
          var steps = duration / 20;   // arbitrarily picked 20ms for each step
          var increment = range / steps;
          var current = start;
          var more = true;
          function next() {
              current = current + increment;
              if (goingUp) {
                  if (current > end) {
                      current = end;
                      more = false;
                  }
              } else {
                  if (current < end) {
                      current = end;
                      more = false;
                  }
              }
              el.style.opacity = current;
              if (more) {
                  setTimeout(next, 20);
              }
          }
          next();
      },
      getGravatarUrl: function(md5) {
        gravatarUrl = '//www.gravatar.com/avatar/' + md5 + "?s=" + 48;
        return gravatarUrl
      }     
    });

  </script>

</polymer-element>
